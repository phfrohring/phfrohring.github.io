<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <title>Pierre-Henry Fröhring</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" type="text/css"/>
        <link rel="stylesheet" type="text/css" href="/css/style.css"/>
                <link rel="icon" type="image/png" href="/images/favicon.png"/>
                    </head>

    <body>
        <div class="top-wrapper">
            <header class="top-header" title="Photo by Laura Lefurgey-Smith on Unsplash." style="background-image: url(/images/header-orig-blockchain-2972.jpg);background-size: cover; background-position: center;"></header>

            <div class="columns_1">
                <nav class="navigation">
                    <ul class="list_of-predifined_publications">
                        <li class="predefined_publication"><a href="/pubs/curriculum-vitae-c5566488.html">CV</a></li>
                        <li class="predefined_publication"><a href="/">Search</a></li>
                    </ul>
                    <input class="card search_box" type="text" id="search_box" placeholder="some words   tag:some_tag">
                </nav>

                <div class="content">
                    <div class="publication-wrapper">
                                                <header>
                            <h1 class="title">Dencentralized consensus</h1>
                                                        <p class="abstract">BitCoin is a decentralized consensus over an append only ledger of blocks a.k.a. the Blockchain.</p>
                                                                                                                <p class="date">2017-08-04</p>
                                                                                    <p class="author">Pierre-Henry Fröhring</p>
                                                    </header>
                                                                        <nav id="TOC">
                            <ul>
                            <li><a href="#bitcoin-dencentralized-consensus">BitCoin : Dencentralized Consensus</a><ul>
                            <li><a href="#notations">Notations</a></li>
                            <li><a href="#crypo-101">Crypo 101</a><ul>
                            <li><a href="#merkle-tree">Merkle Tree</a></li>
                            </ul></li>
                            <li><a href="#bitcoin">BitCoin</a><ul>
                            <li><a href="#transaction">Transaction</a></li>
                            <li><a href="#block">Block</a></li>
                            <li><a href="#bitcoinnode-miner">BitCoinNode ≡ Miner</a></li>
                            <li><a href="#bitcoinnetwork">BitCoinNetwork</a></li>
                            </ul></li>
                            <li><a href="#people-using-bitcoin">People using BitCoin</a><ul>
                            <li><a href="#agreements">Agreements</a></li>
                            <li><a href="#in-practice">In practice</a></li>
                            <li><a href="#currency-exchange-markets">Currency Exchange Markets</a></li>
                            </ul></li>
                            <li><a href="#anonymity">Anonymity</a><ul>
                            <li><a href="#zerocoin">Zerocoin</a></li>
                            <li><a href="#zerocash">Zerocash</a></li>
                            </ul></li>
                            </ul></li>
                            <li><a href="#beyond-bitcoin">Beyond BitCoin</a><ul>
                            <li><a href="#puzzle-requirements">Puzzle requirements</a><ul>
                            <li><a href="#asic-resistant-puzzles">ASIC resistant puzzles</a></li>
                            <li><a href="#proof-of-usefulwork">Proof-Of-UsefulWork</a></li>
                            <li><a href="#nonoutsourceable-puzzles">Nonoutsourceable puzzles</a></li>
                            <li><a href="#virtual-mining">Virtual Mining</a></li>
                            </ul></li>
                            <li><a href="#built-on-bitcoin">Built on BitCoin</a></li>
                            <li><a href="#altcoins">Altcoins</a></li>
                            <li><a href="#future-of-bitcoin">Future of BitCoin?</a></li>
                            <li><a href="#what-to-decentralize">What to decentralize?</a></li>
                            </ul></li>
                            </ul>
                        </nav>
                                                <h1 id="bitcoin-dencentralized-consensus">BitCoin : Dencentralized Consensus</h1>
<h2 id="notations">Notations</h2>
<ul>
<li>‘abcdfegh ≡ X’ means that ‘abcdfegh’ and ‘X’ symbols are interchangeable. You have to infer the scope. It’s really just a shorthand for ‘a.k.a.’</li>
<li>‘a = b’ means that a computation ‘=’ with argument ‘a’ and ‘b’ will check if they are equal according to its implementation.</li>
<li>‘A,B,C ⊢ E,F,G’ ≡ from assumptions A,B,C we can conclude that E,F,G</li>
<li>OrderedList ≡ [a,b,c, …, z]</li>
<li>UnorderedList ≡ [a b c … z]</li>
<li>OrderedSet ≡ {a,b,c,…,z}</li>
<li>UnorderedSet ≡ {a b c … z}</li>
<li>s,s’:String ↦ ss’ where ss’ symbolises the concatenation of s and s’</li>
<li>‘«x»’ means that «x» is to be replaced by what ‘x’ represents e.g.: ‘«sig»’</li>
<li>‘□’ means that something is missing. Should be replaced by something.</li>
</ul>
<h2 id="crypo-101">Crypo 101</h2>
<ul>
<li>Hash ≡
<ul>
<li>String Int → String</li>
<li>length hash s i = i</li>
<li>s,s’:String, s ≠ s’, P(hash s i = hash s’ i) ~ 0</li>
<li>‘r:Seed, s:String, P(hash rs i ⊢ s) ~ 0’ ≡ PuzzleFriendly</li>
<li>Fast</li>
</ul></li>
<li>Commitment ≡ commit verify
<ul>
<li>commit : msg → commitment key</li>
<li>verify : msg commitment key → Boolean</li>
<li>P(com ⊢ msg) ~ 0</li>
<li>P(com ⊢ msg’, verify(com, msg’,key) = true) ~ 0</li>
</ul></li>
<li>Pointer ≡ A piece of data that can be exchanged for an other one.</li>
<li>HashPointer ≡ A piece of data that can be exchanged for an other one and is the hash of it.</li>
<li>DigitalSignatures ≡
<ul>
<li>identity : → secret-key public-key</li>
<li>sign : doc secret-key → signature</li>
<li>verify : doc signature pub-key → Boolean</li>
<li>P({ {doc sig pub-key} } doc’ ⊢ verify(doc’ forged-sig pub-key) = true) ~ 0</li>
</ul></li>
<li>DistributedConsensus ≡ Algorithm that when it terminates, guaranties that correct nodes all agree on a value proposed by a correct node.</li>
</ul>
<h3 id="merkle-tree">Merkle Tree</h3>
<p><a href="https://en.wikipedia.org/wiki/Merkle_tree">Wikipedia</a></p>
<h2 id="bitcoin">BitCoin</h2>
<h3 id="transaction">Transaction</h3>
<p>Transaction ≡ Tx ≡</p>
<ul>
<li>{ Action Signature }. An Action example: “Send 8 of my coins (HashPointer) to Bob.”</li>
<li>For each source of consumed bitcoins should come the signature of the Tx by the corresponding owner.</li>
<li>Sources of Bitcoins are entirely consumed during a Tx e.g. A: 3 BitCoins and A → B : 1 then Tx : { A:3, A → B: 1, A → A: 2 }. Avoid the need to check history too far if only transfers like A → B: 1 where recorded in Tx.</li>
<li>fee:
<ul>
<li>Fluctuates.</li>
<li>If you pay fees then Tx processed faster.</li>
<li>Fees should eventually be the main miners incentive.</li>
</ul></li>
</ul>
<h4 id="pay-to-publickeyhash">Pay-To-PublicKeyHash</h4>
<ul>
<li>B spends what A sent to him</li>
<li>A created scriptPubKey = OP_DUP OP_HASH160 «B pub key hash» OP_EQUALVERIFY OP_CHECKSIG</li>
<li>B creates scriptSig = «sig» «B pub key»,
<ul>
<li>«sig» is created from B private key and this entire Tx (except the signature).</li>
</ul></li>
<li>Input addresses of Tx ≡ scriptSig and output addresses of Tx ≡ scriptPubKey are in fact scripts.</li>
<li>scriptValidation = (concat scriptSig scriptPubKey) should execute w/o error.</li>
<li>Script: stack base, Forth-like, Time/Memory limited ⇒ No loops, No halting problem.</li>
<li>scriptValidation execution stack (hypothesis: no errors):
<ul>
<li>stack:</li>
<li>stack: «sig»</li>
<li>stack: «sig» «B pub key»</li>
<li>stack: «sig» «B pub key» «B pub key»</li>
<li>stack: «sig» «B pub key» «B pub key hash»</li>
<li>stack: «sig» «B pub key» «B pub key hash» «B pub key hash»</li>
<li>stack: «sig» «B pub key»</li>
<li>stack: True</li>
<li>Conclusion: B has proven that he is the legit receiver of the coins send by A. He can now spend them.</li>
</ul></li>
</ul>
<h4 id="op_checkmultisig">OP_CHECKMULTISIG</h4>
<ul>
<li>Assume: n public keys, k signatures, t:Integer</li>
<li>Conclude: (eval ‘at least t (pubKey,sign) matches’)</li>
<li>Implementation bug: pop an extra data, so have to add a dummy one.</li>
</ul>
<h4 id="proof-of-burn">Proof-Of-Burn</h4>
<ul>
<li>Tx such that output BTC cannot be spent.</li>
<li>scriptPubKey: OP_RETURN «arbitrary data»</li>
<li>Usage: proof of knowledge, bootstrap an other crypto currency, …</li>
</ul>
<h4 id="pay-to-scripthash">Pay-To-ScriptHash</h4>
<ul>
<li>scriptPubKey: OP_HASH160 «hash of script» OP_EQUAL</li>
<li>scriptSig: «sig» ««pubkey» OP_CHECKSIG»</li>
<li>scriptValidation execution stack (hypothesis: no errors):
<ul>
<li>stack:</li>
<li>stack: «sig»</li>
<li>stack: «sig» ««pubkey» OP_CHECKSIG»</li>
<li>stack: «sig» ««pubkey» OP_CHECKSIG» «««pubkey» OP_CHECKSIG» hash»</li>
<li>stack: «sig» ««pubkey» OP_CHECKSIG» «««pubkey» OP_CHECKSIG» hash» «hash of script»</li>
<li>stack: «sig» «pubkey» OP_CHECKSIG</li>
<li>stack: True</li>
<li>Conclusion: A agreed that a script with a given hash can dispose of its BTC. B provided the corresponding script that ended up challenging the spender to be B. B provided an additional signature and passed the challenge. B can spend A’s BTC.</li>
<li>Usage: the spender just have to accept a hash to pay.</li>
</ul></li>
</ul>
<h4 id="escrow-transactions">Escrow Transactions</h4>
<ul>
<li>A wants B to ship X of price x to A.</li>
<li>A wants to pay B when X is shipped.</li>
<li>B wants to be paid before X is shipped.</li>
<li><p>⇒ Deadlock.</p></li>
<li>A wants B to ship X of price x to A.</li>
<li>A,B,J emit a Multisig A,B,J 2 on x BTC of Alice.</li>
<li>Case 1
<ul>
<li>B sends X and signs the multisig for: “Pay x to B”.</li>
<li>A receives X and signs the multisig for: “Pay x to B”.</li>
<li>⇒ Pay x to B</li>
</ul></li>
<li>Case 2
<ul>
<li>B signs the multisig for: “Pay x to B”.</li>
<li>A signs the multisig for: “Pay x to A”.</li>
<li>J signs the multisig for: “Pay x to A”.</li>
<li>⇒ Pay x to A.</li>
</ul></li>
<li>Case 3
<ul>
<li>B sends X and signs the multisig for: “Pay x to B”.</li>
<li>A signs the multisig for: “Pay x to A”.</li>
<li>J signs the multisig for: “Pay x to B”.</li>
<li>⇒ Pay x to B.</li>
</ul></li>
</ul>
<h4 id="green-addresses">Green addresses</h4>
<ul>
<li>How to pay B if he does not have access to the Blockchain?</li>
<li>Directly, you cannot: there is no address to send BTC to.</li>
<li>You may send BTC to a third party (e.g. a bank) who does have an address and the bank can tell B that he has been paid.</li>
<li>Third party guarantees agains double spend attack (thus: green address) else goes bust. Instawallet and Mount Gox went bust exactly this way.</li>
<li>Now, people are nervous about green addresses.</li>
</ul>
<h4 id="micro-payments">Micro payments</h4>
<ul>
<li>If Tx.value is less than Tx.fee then self defeating: one pays Tx.value + Tx.fee which is &gt;&gt; than Tx.value.</li>
<li>Solution: aggregate small Tx into one big Tx so that Tx.fee &lt;&lt; Tx.value.</li>
<li>Protocol:
<ul>
<li>A : pay 100 to Multisig A,B 2 from A.</li>
<li>XXX: A : pay 100 to A, from Multisig A,B signed by A and B not until time t.</li>
<li>A : pay 1 to B, 99 to A, signed by A from Multisig A,B. Dismissed!</li>
<li>… Dismissed!</li>
<li>A : “Ok finished!” B : “Ok, signing!”</li>
<li>A : pay 42 to B, 58 to A, signed by A and B from Multisig A,B. Validated!</li>
<li>⇒ pay 42 to B, 58 to A from Multisig A,B.</li>
<li>when time t comes, Tx XXX is invalid.</li>
<li>if bob do not sign in time then A is refunded.</li>
</ul></li>
</ul>
<h3 id="block">Block</h3>
<ul>
<li>Block ≡
<ul>
<li>Transactions ≡ {Tx,…,Tx}</li>
<li>BlockHash ≡ hashpointer to the block it extends</li>
<li>TxHash ≡ hashpointer to the Merkle tree of Tx</li>
<li>Nounce ≡ solution of a HashPuzzle</li>
<li>… see e.g., <a href="https://blockchain.info">blockchain.info</a></li>
</ul></li>
<li>Why Blocks?
<ul>
<li>Processing overhead for single Tx would be too high.</li>
<li>Addressing indirection for a Tx: Block.Tx instead of Tx: addresses are shorter.</li>
</ul></li>
</ul>
<h3 id="bitcoinnode-miner">BitCoinNode ≡ Miner</h3>
<ul>
<li>Has consensus blocks {Block,…,Block}</li>
<li>Has blocks to reach consensus upon [Block,…,Block]</li>
<li>Has no identity</li>
<li>Can broadcast Tx</li>
<li>HashPuzzle so hard that header so sometime not enough to find the nounce: use the coinbase field.</li>
</ul>
<h3 id="bitcoinnetwork">BitCoinNetwork</h3>
<ul>
<li>Runs on TCP, port 8333</li>
<li>Ad-hoc network, random topology</li>
<li>All nodes are equal, software wise.</li>
<li>Dynamic: new node can join/leave anytime</li>
<li>Inactive nodes for &gt; 3Hr are forgotten</li>
<li>Incentive: Block reward</li>
<li>Incentive: Tx fee</li>
<li>HashPuzzle ≡ solve hash256(nounce prev-hash tx … tx) ∈ target-space for nounce. target-space is chosen by the network so that the average time to find a nounce is ~ 10 min.</li>
<li>Proof-Of-Work ≡ Select node in proportion to its computing power i.e. its ability to solve hash puzzles. Trivial for anyone to verify that puzzle was solved: check that hash256(block.nounce …) ∈ target.</li>
<li><strong>Randomly</strong> choosen node to suggest a block to the network is approximated by Proof-Of-Work</li>
<li>Round ≡ a node is randomly chosen and suggests a block</li>
<li>Check if block is valid (unspent, valid tx)</li>
<li>Nodes either prolong their concensus chain with this block or a block from an earlier round because of incentives.</li>
<li>Network properties:
<ul>
<li>As long as a majority of miners weighted by computing power are honest, BitCoin is secure.</li>
<li>It’s a currency: it includes incentives for nodes to act honestly (by the rules).</li>
<li>Nodes reach consensus upon one {Block,Block,…} ≡ Blockchain</li>
<li>Works despite disconnected Nodes</li>
<li>Works despite crashed Nodes</li>
<li>Works despite malicious Nodes</li>
<li>Works despite network latency</li>
<li>Works despite Byzentine general problem</li>
<li>Works despite FischerLynchPaterson</li>
<li>Works despite many others <em>a priori</em> impossibilities</li>
<li>Nodes w/o identity → protect from Sybil Attacks</li>
<li>No starting point for the consensus: reached in 1H, not matter where it originated from → Never sure but wrong consensus is exponentially less likely to happen.</li>
</ul></li>
</ul>
<h4 id="joining-the-network">Joining the network</h4>
<ul>
<li>Ask one (also first) node of the network (≡ seed node) randomly chosen the list of all his peers.</li>
<li>Repeat w/ the fetched peers arbitrarily.</li>
</ul>
<h4 id="propagating-tx">Propagating Tx</h4>
<ul>
<li>If given a new Tx then tell to as many peers as you can.</li>
<li>They can decide to do the same thing.</li>
<li>Decision is arbitrary but some sensible default:
<ul>
<li>Have I already propagated it?</li>
<li>Is the script standard?</li>
<li>Is the Tx valid?</li>
<li>Is it a double spend?</li>
</ul></li>
</ul>
<h4 id="propagating-blocks">Propagating Blocks</h4>
<ul>
<li>If given a new Tx then tell to as many peers as you can.</li>
<li>They can decide to do the same thing.</li>
<li>Decision is arbitrary but some sensible default:
<ul>
<li>HashPuzzle solved?</li>
<li>All Tx valid?</li>
<li>Built on longest chain? (else try to fork)</li>
</ul></li>
</ul>
<h4 id="limits">Limits</h4>
<ul>
<li>10min avg creation time per block</li>
<li>≤ 1Mb per block</li>
<li>≤ 20k signature operations per block</li>
<li>&gt; 250 bytes per Tx</li>
<li><p>⇒ 7 Tx/sec. 2k ≤ Visa ≤ 10k, 50 ≤ PayPal ≤ 100</p></li>
<li>1 signature algorithm ECDSA/P256</li>
<li>hard-coded hash functions</li>
<li><p>⇒ Broken after 2040?</p></li>
<li>100m satoshis per BTC</li>
<li>≤ 21M BTC</li>
<li><p>50,25,12.5,… BTC mining reward.</p></li>
</ul>
<h4 id="upgrading-bitcoin">Upgrading BitCoin</h4>
<ul>
<li>HardFork: Some nodes update the SW others do not ⇒ Network split ⇒ Chain split</li>
<li>SoftFork: Some nodes just deal w/ stricter protocol so that just a sub case of a more general one: no split. Old nodes will catch up eventually: they can understand the new protocol.</li>
</ul>
<h2 id="people-using-bitcoin">People using BitCoin</h2>
<ul>
<li>Only thing specific to each user are their keys.</li>
<li>⇒ How to make them safe and easy to use?</li>
<li>Local storage?</li>
<li>Easy to use but not secure.</li>
<li>Wallet software</li>
<li>Hot storage | Cold storage : ideally no decypherable link between the two.</li>
<li>How to transfert coins from hot storage to cold storage?</li>
<li>Cannot transfert to 1 cold storage address else becomes a target.</li>
<li>Hierarchical key generation</li>
<li>Storing secret cold keys: in a locked device (safe, paper, brain, …) &amp; tamperproof device</li>
<li>Until now: single place of storage ⇒ single point of failure. How to avoid that?</li>
<li>Split keys using a big prime, random numbers and modulo operations.</li>
<li>Still have to bring all the secret together ⇒ single point of failure…</li>
<li>…unless MULTISIG.</li>
</ul>
<h3 id="agreements">Agreements</h3>
<ul>
<li>Agreement on:
<ul>
<li>what makes a Tx valid</li>
<li>what makes a Block valid</li>
<li>how BitCoinNode should behave</li>
<li>BitCoinNetwork protocols</li>
<li>the blockchain ⇒ who owns what now and past Tx</li>
<li>the value a BTC has i.e. against what it can be exchanged. Also, Tinkerbell effect.</li>
</ul></li>
<li>All of the above are potential failure points.</li>
</ul>
<h4 id="bitcoin-core-software">BitCoin Core Software</h4>
<ul>
<li>The <em>de facto</em> spec.</li>
<li>BIPs</li>
</ul>
<h4 id="power-distribution">Power distribution</h4>
<ul>
<li>Developpers</li>
<li>Merchants</li>
<li>Miners</li>
<li>Representative e.g. bitcoin foundation</li>
<li>Payment services e.g. Banks</li>
<li>Investors</li>
</ul>
<h4 id="ideological-roots">Ideological roots</h4>
<ul>
<li>Cypherpunk: libertarian/anarchists</li>
<li>Decentralized, private, secure</li>
<li>Satoshi Nakamoto: has not cash in!</li>
</ul>
<h4 id="governments-and-bitcoin">Governments and BitCoin</h4>
<ul>
<li>Untraceable digital cash defeats government capital controls</li>
<li>Untraceable digital cash defeats whole classes of law enforcements: cannot “follow the money”! (silk road)</li>
<li></li>
</ul>
<h3 id="in-practice">In practice</h3>
<ul>
<li>Online wallet: have to trust them.</li>
<li>Exchanges: like banks. Bankruns, Ponzi Scheme, Cyber Attacks. See: Mount Gox.</li>
<li>Proof-Of-Reserve</li>
<li>Payment services</li>
</ul>
<h3 id="currency-exchange-markets">Currency Exchange Markets</h3>
<ul>
<li>To online market places: <a href="http://bitcoincharts.com/markets">Exchanges</a></li>
<li>To people directly: <a href="https://localbitcoins.com/">Localbitcoins</a></li>
</ul>
<h2 id="anonymity">Anonymity</h2>
<ul>
<li>Problem: if Bob ⟷ { PubKey } ⟷ BTC then Bob ⟷ BTC and Bob is the single point of failure an attacker may want to attack. How to make the connection Bob ⟷ { PubKey } ⟷ BTC hard? All Tx are public!</li>
<li>PubKey ~ name</li>
<li>PubKey as name ≡ pseudonymity</li>
<li>Social name ⟷ PubKey impossible (≡ unlinkability)</li>
<li>Anonymity ≡ unlinkability + pseudonymity from the POV of an attacker.</li>
<li>Shared spending → joint control</li>
<li>Lots of techniques to find who’s behind this or that PubKey and or group PubKey together.</li>
<li>Wallet vs Mixer</li>
<li>Not satisfying, lots of caveats.</li>
</ul>
<h3 id="zerocoin">Zerocoin</h3>
<ul>
<li>Suppose BaseCoin behaves ~ to BitCoin</li>
<li>a:BaseCoin → b:ZeroCoin → c:BaseCoin : no way to a ⊢ c or c ⊢ a and protected from double spending attack.</li>
<li>a ZeroCoin is a proof that one has controlled a BaseCoin and has made it unusable but don’t know which one. So: can use an other one. Verification is O(log(n)) and not linear: that’s what makes it practical.</li>
</ul>
<h3 id="zerocash">Zerocash</h3>
<ul>
<li>Basecoins operations (many Tx, split and merge) are useless: all of them done within the zerocoin space.</li>
<li>The ledger of basecoins just records existence of coins not their exchanges.</li>
<li>Random secrets inputs needed to generate pubkeys and destroyed so that no one know them else can destroy the systm. Unsolved bootstraping pb so far (2014).</li>
</ul>
<h1 id="beyond-bitcoin">Beyond BitCoin</h1>
<h2 id="puzzle-requirements">Puzzle requirements</h2>
<ul>
<li>Cheap to verify</li>
<li>Adjustable difficulty</li>
<li>Chances of winning proportional to hashpower</li>
</ul>
<h3 id="asic-resistant-puzzles">ASIC resistant puzzles</h3>
<ul>
<li>Why: because ASICS lead to centralization which defeats ideas behind BitCoin.</li>
<li>Since processing efficientcy grows faster than memory then memory bound puzzle.</li>
<li>Script (Litecoin) but not clear</li>
<li>Cuckoo hash cycle</li>
<li>Moving puzzles</li>
<li>Complicated hashes: X11</li>
<li>Do nothing: marginal benefits already low</li>
</ul>
<h3 id="proof-of-usefulwork">Proof-Of-UsefulWork</h3>
<ul>
<li>2014: 150-900MW mining. Make that useful?</li>
<li>Protein folding? Search for Aliens?</li>
<li>Primecoin</li>
<li>Permacoin</li>
</ul>
<h3 id="nonoutsourceable-puzzles">Nonoutsourceable puzzles</h3>
<ul>
<li>Pools lead to centralization</li>
<li>Vigilante Attack</li>
</ul>
<h3 id="virtual-mining">Virtual Mining</h3>
<ul>
<li>Proof-Of-Stake</li>
<li>Proof-Of-Burn</li>
<li>Proof-Of-Deposit</li>
<li>Proof-Of-Activity</li>
</ul>
<h2 id="built-on-bitcoin">Built on BitCoin</h2>
<ul>
<li>Proof of knowledge ~ Proof of receipt</li>
<li>BlockChain poisoning</li>
<li>Mastercoin</li>
<li>Colored coins</li>
<li>OpenAssets</li>
<li>MultyParties lottery</li>
<li>Cryptography beacons</li>
</ul>
<h2 id="altcoins">Altcoins</h2>
<ul>
<li>Namecoin</li>
<li>Litecoin</li>
<li>Peercoin</li>
<li>Dogecoin</li>
<li>Criteria:
<ul>
<li>Market cap</li>
<li>Exchange volume</li>
<li>Total hashpower</li>
<li>Merchant support</li>
<li>Usage</li>
</ul></li>
<li>Mining attack</li>
<li>Merge mining</li>
<li>Sidechains</li>
</ul>
<h2 id="future-of-bitcoin">Future of BitCoin?</h2>
<ul>
<li>Smart property</li>
<li>Decentralized property ownership</li>
<li>Crowd funding</li>
<li>Pay for proof</li>
<li>Decentralize X in wrt Y using Z via T</li>
</ul>
<h2 id="what-to-decentralize">What to decentralize?</h2>
<ul>
<li>Security ≡ f(preventive,detective,corrective)</li>
</ul>
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>
